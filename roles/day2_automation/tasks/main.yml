---
# tasks file for day2 automation
- name: Set fact for {{ common_ip_space }} IPv4 address
  set_fact:
    ipv4_address: "{{ ansible_all_ipv4_addresses | select('match', '^' + common_ip_space + '\\.') | list }}"
  when: ipv4_address is undefined

- name: Check for valid IP
  ansible.builtin.fail:
    msg: "No valid IP found for git host {{ ipv4_address }}"
  when: "{{ ipv4_address[0] is undefined or not ipv4_address[0] is ansible.utils.ip }}"
  
- name: Generate day2 values file
  ansible.builtin.template:
    src: "day2-values-file.j2"
    dest: "{{ playbook_dir }}/../helm/openshift-gitops-day2/ansible_values.yaml"
    mode: '0755'
    owner: git
    group: git
  become: true
  register: day2_values

- name: Generate stage3 values file
  ansible.builtin.template:
    src: "day2-values-file.j2"
    dest: "{{ playbook_dir }}/../helm/stage3/ansible_values.yaml"
    mode: '0755'
    owner: git
    group: git
  become: true
  register: day2_values

- name: Get existing remotes
  ansible.builtin.command:
    cmd: "git remote"
  register: remote_status

- name: Check for localhost remote
  ansible.builtin.debug:
    msg: "localhost remote found"
  when: "{{ remote_status.stdout is search('localhost') }}"

- name: Update remotes to include the local git host path
  ansible.builtin.command:
    cmd: "git remote add localhost git@{{ipv4_address[0]}}:/home/git/repos/ocp4-disconnected-config"
  when: "{{ not remote_status.stdout is search('localhost') }}"

- name: Check for changes before commiting
  ansible.builtin.command:
    cmd: "git status"
  register: git_status

- name: Commit updated values files
  ansible.builtin.shell: |
    pwd
    git add . 
    git commit -am 'update day2 values from ansible'
  args:
    chdir: "{{ playbook_dir }}/../"
  register: git_output
  when: "{{ not git_status.stdout is search('nothing to commit') }}"

# - name: debug output
#   ansible.builtin.debug:
#     msg: "{{ git_output.stdout }}"
#   when: "{{ not git_status.stdout is search('nothing to commit') }}"

- name: Push changes to localhost remote
  ansible.builtin.command:
    cmd: "git -c core.sshCommand='ssh -o StrictHostKeyChecking=accept-new' push localhost"
  args:
    chdir: "{{ playbook_dir }}/../"
  when: "{{ not git_status.stdout is search('nothing to commit') }}"

- name: Generate day2 app config
  ansible.builtin.template:
    src: "day2-argo-app.j2"
    dest: "{{ playbook_dir }}/day2-argo-app.yaml"
    mode: '0644'
    owner: "{{ ansible_user_id }}"
    group: wheel
  become: true
  register: day2_config

- name: Create day2 app in OpenShift
  ansible.builtin.command:
    cmd: "oc apply -f {{ playbook_dir }}/day2-argo-app.yaml"
  when: day2_config.changed
  register: create_day2_app_status

- name: Output from creating day2 app
  ansible.builtin.debug:
    msg: "{{ create_day2_app_status.stdout }}"
  when: debug | bool

- name: Cleanup day2 app config file
  ansible.builtin.file:
    path: "{{ playbook_dir }}/day2-argo-app.yaml"
    state: absent
  when: not debug | bool

- name: Check ArgoCD application status with retries
  ansible.builtin.shell: |
    oc get application cluster-day2 -n openshift-gitops -o json
  register: app_status
  changed_when: false
  until: >
    (app_status.stdout | from_json).status.health.status == "Healthy"
    and (app_status.stdout | from_json).status.sync.status == "Synced"
  retries: 10  # Number of attempts
  delay: 15    # Delay in seconds between retries
  failed_when: app_status.stdout is not defined
  
- name: Parse and display final application status
  vars:
    health_status: "{{ (app_status.stdout | from_json).status.health.status }}"
    sync_status: "{{ (app_status.stdout | from_json).status.sync.status }}"
  debug:
    msg: >
      Final status of application "{{ day2_app_name }}":
      Health: {{ health_status }}, Sync: {{ sync_status }}
  
- name: Fail if application did not become healthy and synced
  fail:
    msg: >
      Application "{{ day2_app_name }}" did not reach the expected state.
      Current Health: {{ health_status }}, Sync Status: {{ sync_status }}
  when: health_status != "Healthy" or sync_status != "Synced"

- name: Generate stage3 app config
  ansible.builtin.template:
    src: "stage3-argo-app.j2"
    dest: "{{ playbook_dir }}/stage3-argo-app.yaml"
    mode: '0644'
    owner: "{{ ansible_user_id }}"
    group: wheel
  become: true
  register: stage3_config

- name: Create stage3 app in OpenShift
  ansible.builtin.command:
    cmd: "oc apply -f {{ playbook_dir }}/stage3-argo-app.yaml"
  when: stage3_config.changed
  register: create_stage3_app_status

- name: Output from creating stage3 app
  ansible.builtin.debug:
    msg: "{{ create_stage3_app_status.stdout }}"
  when: debug | bool

- name: Cleanup stage3 app config file
  ansible.builtin.file:
    path: "{{ playbook_dir }}/stage3-argo-app.yaml"
    state: absent
  when: not debug | bool

- name: Check ArgoCD application status with retries
  ansible.builtin.shell: |
    oc get application cluster-stage3 -n openshift-gitops -o json
  register: app_status
  changed_when: false
  until: >
    (app_status.stdout | from_json).status.health.status == "Healthy"
    and (app_status.stdout | from_json).status.sync.status == "Synced"
  retries: 10  # Number of attempts
  delay: 15    # Delay in seconds between retries
  failed_when: app_status.stdout is not defined
  
- name: Parse and display final application status
  vars:
    health_status: "{{ (app_status.stdout | from_json).status.health.status }}"
    sync_status: "{{ (app_status.stdout | from_json).status.sync.status }}"
  debug:
    msg: >
      Final status of application "{{ stage3_app_name }}":
      Health: {{ health_status }}, Sync: {{ sync_status }}
  
- name: Fail if application did not become healthy and synced
  fail:
    msg: >
      Application "{{ stage3_app_name }}" did not reach the expected state.
      Current Health: {{ health_status }}, Sync Status: {{ sync_status }}
  when: health_status != "Healthy" or sync_status != "Synced"